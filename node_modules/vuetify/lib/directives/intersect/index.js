function inserted(el, binding, vnode) {
  if (typeof window === 'undefined' || !('IntersectionObserver' in window)) return;
  const modifiers = binding.modifiers || {};
  const value = binding.value;
  const {
    handler,
    options
  } = typeof value === 'object' ? value : {
    handler: value,
    options: {}
  };
  const observer = new IntersectionObserver((entries = [], observer) => {
    var _el$_observe;

    if (!((_el$_observe = el._observe) != null && _el$_observe[vnode.context._uid])) return; // Just in case, should never fire

    const _observe = el._observe[vnode.context._uid];
    const isIntersecting = entries.some(entry => entry.isIntersecting); // If is not quiet or has already been
    // initted, invoke the user callback

    if (handler && (!modifiers.quiet || _observe.init) && (!modifiers.once || isIntersecting || _observe.init)) {
      handler(entries, observer, isIntersecting);
    }

    if (isIntersecting && modifiers.once) unbind(el, binding, vnode);else _observe.init = true;
  }, options);
  el._observe = Object(el._observe);
  el._observe[vnode.context._uid] = {
    init: false,
    observer
  };
  observer.observe(el);
}

function unbind(el, binding, vnode) {
  if (!el._observe) return;

  el._observe[vnode.context._uid].observer.unobserve(el);

  delete el._observe[vnode.context._uid];
}

export const Intersect = {
  inserted,
  unbind
};
export default Intersect;
//# sourceMappingURL=index.js.map